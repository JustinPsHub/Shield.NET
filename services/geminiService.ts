import { ChatResponse, AuditLog } from '../types';

/**
 * Simulates a cryptographic hash function for the Audit Log.
 * In production, this would be a SHA-256 hash generated by the C# Backend.
 * @param str The user input to hash.
 */
const simpleHash = (str: string): string => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return "HASH-" + Math.abs(hash).toString(16).toUpperCase();
};

/**
 * The core simulation logic mimicking the C# LocalPiiDetector.
 * It enforces the "Source of Truth" behavior by applying strict regex
 * patterns to catch PII, specifically the Trap Scenario entities.
 */
const redactPII = (input: string): { redactedText: string; detectedTypes: string[] } => {
  let redactedText = input;
  const detectedTypes: string[] = [];

  // Regex for Email: Matches standard formats including sarah.connor@sky.net
  const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
  if (emailRegex.test(redactedText)) {
    detectedTypes.push("Email");
    redactedText = redactedText.replace(emailRegex, "<EMAIL>");
  }

  // Regex for IPv4: Matches 192.168.1.45
  const ipRegex = /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
  if (ipRegex.test(redactedText)) {
    detectedTypes.push("IPAddress");
    redactedText = redactedText.replace(ipRegex, "<IP>");
  }

  // Trap for Prompt Injection
  if (input.toLowerCase().includes("ignore previous instructions")) {
     detectedTypes.push("PromptInjection");
  }

  return { redactedText, detectedTypes };
};

/**
 * Simulates the async call to the Shield Middleware.
 * Returns a ChatResponse object that mirrors the C# structure.
 */
export const sendMessageToGemini = async (message: string): Promise<ChatResponse> => {
  return new Promise((resolve) => {
    // Simulate network latency (800ms) to make the "Processing..." state visible
    setTimeout(() => {
      // 1. Execute the PII Detection Logic
      const { redactedText, detectedTypes } = redactPII(message);
      const wasRedacted = detectedTypes.length > 0;
      const isBlocked = detectedTypes.includes("PromptInjection");

      // 2. Generate the Audit Record
      // Properties use PascalCase to match C# AuditRecord serialization
      const auditRecord: AuditLog = {
        AuditId: crypto.randomUUID(),
        CorrelationId: `CID-${Date.now()}`,
        UserPromptHash: simpleHash(message),
        Timestamp: new Date().toISOString(),
        SafetyDecision: isBlocked ? 'Blocked' : (wasRedacted ? "Redacted" : "Approved"),
        WasRedacted: wasRedacted,
        DetectedPiiTypes: detectedTypes,
        OriginalPromptLength: message.length
      };

      // 3. Construct the Final Response
      const response: ChatResponse = {
        id: crypto.randomUUID(),
        content: isBlocked ? "[BLOCKED BY SHIELD.NET]" : redactedText,
        isRedacted: wasRedacted,
        timestamp: new Date().toISOString(),
        auditRecord: auditRecord
      };

      resolve(response);
    }, 800);
  });
};
// Re-export alias to maintain backward compatibility if needed, 
// though Dashboard now uses sendMessageToGemini directly.
export const analyzeInputWithShield = sendMessageToGemini;
